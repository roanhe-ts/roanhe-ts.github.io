---
layout: post
title:  "C++对象模型之虚函数表"
date:   2021-02-10 17:39:11 +0800
categories: jekyll update
---

# 虚函数表
虚函数表（Virtual function table）更加朴素的叫法应该是“虚函数指针数组”，顾名思义，**该数组内所有元素都是函数指针，这些指针指向该类的虚函数**。
## 虚函数表的基本性质
### 虚函数表指针
```c++
class Base{
public:
    virtual void f(){cout<< "Base:f()" << endl;}
    virtual void g(){cout<< "Base:g()" << endl;}
    virtual void h(){cout<< "Base:h()" << endl;}
};

class Drive : public Base{
public:
    void g() override {cout<< "Drive::g()" << endl;}
};
```
首先，我们这里定义了基类Base和派生类Drive，一个小细节是Drive覆盖了基类的虚函数`void g()`。
现在我们希望去验证一下确实有虚函数表这个东西，可以这么做：

```c++
typedef void(* func_ptr)(void);

Base b{};
func_ptr** vft_pptr = reinterpret_cast<func_ptr**>(&b);
func_ptr* vft_ptr = *vft_pptr;

printf("Address of b: %p\n", &b);

printf("First 8 bytes of b: %p\n", *(reinterpret_cast<func_ptr**>(&b)));
printf("Dereferrence content of b: %p\n", *(*(reinterpret_cast<func_ptr**>(&b))));

for(int i = 0; i < 3; ++i){
    printf("vft_base[%d] = 0x: %p\n", i, vft_ptr[i]);
}

for(int i = 0; i < 3; ++i){
    vft_ptr[i]();
}
```
我们首先实例化了一个`Base`类。然后`typedef`了一个函数指针类型别名`func_ptr`。
既然虚函数表是一个虚函数指针数组，那么虚函数表就可以声明为`func_ptr vft_base[];`或者等价于`func_ptr* vtf_base;`。
对于具有虚函数表的类对象内存布局，其内存布局的第一个8字节保存的是一个指针，该指针指向这个类的虚函数表，称为虚函数表指针，可以声明为`func_ptr* vtf_ptr;`，为了获得该指针的值，需要将b的地址转换为一个`func_ptr**`类型，这样才能读取到这8个字节的值。

随后第一个for循环打印出这个虚函数表中的每个元素的值，也就是所有虚函数的地址。既然我们找到了这些虚函数的地址，那么我们就可以在第二个for循环内正常地调用这些函数。

执行后的结果：
```bash
Address of b: 0x113517170
First 8 bytes of b: 0x112d56380
Dereferrence content of b: 0x113075130
vft_base[0] = 0x: 0x113075130
vft_base[1] = 0x: 0x113075190
vft_base[2] = 0x: 0x1130751f0
Base:f()
Base:g()
Base:h()
```
通过将变量B的内容reinterpret_cast为一个指向`func_ptr`的指针，然后解引用该指针，发现结果等于`vft_base[0]`。**这说明B对象的前8个字节确实保存的是指向虚函数表的指针**。最后的内存布局如下图所示。
<img src="./../images/df96378b26c5d0405e36617686f7fa4f8ab49e8a965edd74736dd9046f669829.png"/>

**同一个类的所有对象共享一个虚函数表**。验证一下：
```c++
Base b1{};
printf("Content of b1: %p\n", *(reinterpret_cast<func_ptr**>(&b1)));

Base b2{};
printf("Content of b1: %p\n", *(reinterpret_cast<func_ptr**>(&b2)));
```
```bash
Content of b1: 0x112d56380
Content of b2: 0x112d56380
```
这说明同一个类的对象共享同一个虚函数表。
![picture 2](../../images/87713a91002d3734aa8669398df0d5eb6de78b4b8f6e8e571ebf233c7198e7dc.png)  

## 继承关系下的虚函表

对派生类我们还就内个故技重施，如下：
```c++
Drive d{};
printf("Address of vft of Drive: %p\n", *(reinterpret_cast<func_ptr**>(&d)));

func_ptr* vft_drive = *(reinterpret_cast<func_ptr**>(&d));

for(int i = 0; i < 3; ++i){
    printf("vft_drive[%d] = %p\n", i, vft_drive[i]);
}

for(int i = 0; i < 3; ++i){
    vft_drive[i]();
}
```
执行结果：
```bash
Address of vft of Drive: 0x11351e750
vft_drive[0] = 0x113075130
vft_drive[1] = 0x11351f1d0
vft_drive[2] = 0x1130751f0
Base:f()
Dirve:g()
Base:h()
```
可以观察并总结出以下几点：
1. Drive与Base的虚函数表地址不同，说明继承类具有自己的虚函数表。
2. 两个虚函数表中`f()`与`h()`的地址都相同，说明继承类调用了基类的未被覆盖的虚函数`f()`与`h()`
3. 基类和派生类的虚函数`g()`具有不同的地址，基类的虚函数g地址位于f与h之间，这跟函数声明的顺序相同，派生类中的虚函数g地址则相对较远

此时我们得到的内存分布如下：
![picture 3](../../images/a761a51a8bb66ad138f022def0ef5299aad76d44765f6c23a62f25c80f3d4cd7.png)  


## 多重继承下的虚函数表