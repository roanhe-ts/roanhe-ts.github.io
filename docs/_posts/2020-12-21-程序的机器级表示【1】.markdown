---
layout: post
title:  "程序的机器级表示【1】"
date:   2020-12-21 17:31:48 +0800
categories: jekyll update
---
想要开一个系列用于记录对 x86-64 汇编的学习过程。本系列与 CSAPP《深入理解计算机系统》第三章同名，是我对这一章学习内容的自述式总结。

先从一个简单的 Demo 开始。
一段简单的 C 代码如下
```c
long exchange(long *xp, long y)
{
  long x = *xp;
  *xp = y;
  return x;
}
```
这段 C 代码作用很简单，将变量 y 的值赋给指针变量 xp 指向的内存地址，然后返回该内存地址的原始值。
看一下对应的汇编代码
```bash
# -Og 表示采用使结果与源代码文件结构类似的优化等级
# -S 表示生成一个汇编文件
$ gcc -Og -S exchange.c
```
得到的汇编如下，我们只截取当前比较重要的部分
```asm
exchange:
	movq	(%rdi), %rax
	movq	%rsi, (%rdi)
	ret
```
初次看这段汇编代码，如果很容易有一种似懂非懂的“迷糊”的感觉。比如 movq 应该是在进行复制，但是这里的 q 是什么含义？rdi 看起来像寄存器，但是外边加括号表示什么呢？

## 为了看懂 demo 来点预热
为了彻底看懂这段 demo，我们需要从寄存器表示开始学习，到数据传送指令，再到操作数如何寻址。

### 寄存器表示
x86-64 一共有 16 个**通用**寄存器，通用表示这些寄存器可以用来保存整数数据和指针。所有这些寄存器都是 64 位。这些寄存器的命令规则既有现在的命名规范限制，也有历史继承。我们最常使用的是前 8 个从历史继承来的寄存器，最初他们的命名为：ax，bx，cx，dx，si，di，bp，sp。在 64 位的系统上，为了区别 64 位寄存器的不同位置（有时候我们只需要使用 32 位或者 16 位，需要符号做区别），有如下规则：
  * %rax 表示使用 ax 寄存器的 64 位
  * %eax 表示使用 ax 集群器的低 32 位
  * %ax 表示使用 ax 寄存器的低 16 位
  * %al 表示使用 ax 寄存器的低 8 位
这里用 ax 举例子，其他寄存器类似。

回过头看一下之前的汇编代码里的寄存器标识
```asm
exchange:
	movq	(%rdi), %rax
	movq	%rsi, (%rdi)
	ret
```
%rdi 表示使用的是 di 的全部 64 位，%rax 表示使用 ax 寄存器的全部 64 位，%rsi 和%rdi 同理。
### 数据传送指令
寄存器我们看懂了，指令 movq 具体什么意思呢？
mov 指令用于进行将数据从一个位置复制到另一个位置的工作，通用格式是：`mov S,D`，第一个操作数是源操作数，第二个是目标操作数。后缀字母则用于表示本次复制复制多少个“字”。
历史上 Intel 是从 16 位体系结构一路扩展到现在常见的 64 位体系结构的。最初 Intel 使用术语“字（word）”来表示 16 位的数据类型，继承到现在，就用“双字（double word）”来表示 32 位数据类型，用“四字（quad word）”来表示 64 位数据类型。所以 movq 后缀 q 就是 quad word 的缩写，表示本次复制需要从源操作数拷贝 64 位数据到目的操作数。
所以
```asm
exchange:
	movq	(%rdi), %rax
	movq	%rsi, (%rdi)
	ret
```
中的两个 movq 指令都是进行 64 位数据结构的复制。
### 操作数寻址
最后还剩寄存器外括号如何理解的问题。
前面说到 mov 指令后面跟两个操作数，操作数本质都是某个长度的数据，区别在于这些操作数存放的位置（内存/寄存器/立即数）。通过括号等标记，我们明确了这些操作数在哪个位置，以及我们应该如何访问这些位置。

x86-64 支持三种不同的操作数：
1. $Imm 立即数：ATT 格式汇编代码中使用`$`标记表示后跟一个立即数
2. ra 寄存器：当某个操作数是寄存器时，表示直接使用该寄存器中的值作为操作数。
比如`movq (%rdi), %rax`就是表示将源操作数直接复制到寄存器%rax 中，`movq %rsi, (%rdi)`就是讲寄存器%rsi 中的值复制到目的操作数。
3. 内存引用：表示该操作数位于内存，需要根据有效地址访问某个内存位置。
`(%rdi)`表示使用寄存器%rdi 中的值作为内存地址，访问该地址获得操作数。
还有几种更加复杂的寻址模式：
* Imm(rb, ri, s): 比例变址寻址，最终的操作数位于内存，地址是：Imm + R[rb] + R[ri] * s，R[rb] 表示使用寄存器 rb 的值。比例变址寻址可以有多重变种，变化的方式是这四个参数省去一个或者多个，但是解读方式都一样，对缺少的参数忽略即可。比如 Imm(, ri, s) 表示使用内存地址为 Imm + R[ri]*s 的操作数。

### demo 详解
现在让我们回到 demo
C 代码：
```c
long exchange(long *xp, long y)
{
  long x = *xp;
  *xp = y;
  return x;
}
```
汇编表示：
```asm
exchange:
	movq	(%rdi), %rax
	movq	%rsi, (%rdi)
	ret
```
函数 exchang 的入参 xp 与 y 分别通过寄存器 rdi 和 rdi 传递给函数过程。
`movq (%rdi), %rax`将内存中地址为 R[%rdi] 的 64 位值拷贝到寄存器 %rax 中，完成了语句`long x = *xp;`；
`movq %rsi, (%rdi)`将寄存器 rsi 的值拷贝到内存中地址为 R[%rsi] 的 64 位空间上，完成了语句 `*xp = y`

返回值是通过寄存器 rax 保存的，执行到 ret 语句时，会进行函数过程的切换，回到 caller 过程。具体过程实现之后章节进行介绍。

通过这个 demo，我们对如何阅读汇编有了初步的认识，下一节开始，将会更加仔细的介绍各个指令的作用。