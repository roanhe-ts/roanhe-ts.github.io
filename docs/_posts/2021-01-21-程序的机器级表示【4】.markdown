---
layout: post
title:  "程序的机器级表示【4】"
date:   2021-01-21 00:04:11 +0800
categories: jekyll update
---
<script src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML" type="text/javascript"></script>

[上一章](https://roanhe-ts.github.io/jekyll/update/2020/12/25/%E7%A8%8B%E5%BA%8F%E7%9A%84%E6%9C%BA%E5%99%A8%E7%BA%A7%E8%A1%A8%E7%A4%BA-3.html)写的有些敷衍。但是把握住最关键的几个点就好：

* 无符号数是 C 语言提供的逻辑表示，CPU 只认识有符号补码表示数。
* 几个控制指令，见了认识就行
* 条件分支的实现：条件跳转/条件传送

本篇，终于可以遇到一些比较好玩的不同的东西了。**过程**

## 过程
我们知道 C 语言是面向过程的语言，以我浅薄的理解，面向过程就是把可复用的/独立的代码逻辑用函数来抽象，然后用这些函数来使得代码更加清晰。

过程的实现，需要编译器与 CPU 指令一起配合。以一个最简单的过程 P 调用过程 Q 然后再返回过程 P 的过程来举例，过程机制需要思考如何实现如下动作：
* 过程传递：如何让过程 Q 从 P 中“抢走”CPU，并且在 Q 完成后将 CPU“归还”给过程 P。

这点实现很简单：利用程序计数器（PC）寄存器。在进入过程 Q 的时候 PC 被设置为 Q 的起始指令地址，过程 Q 返回时，将 PC 设置为 P 调用 Q 之后的第一条指令的地址。

* 传递数据：如何把过程 P 中的数据传递给过程 Q
* 分配和释放内存：过程 Q 执行需要内存，过程 Q 执行结束需要再将分配的内存释放。

### 转移控制

|指令 | 描述|
|--|--|
|call|过程调用|
|ret|从过程调用中返回|

`call`和`ret`指令完成了过程传递这一动作。

以 P 调用 Q 再返回 P 为例，当在 P 过程中执行到`call Q`指令时，`call`指令会进行如下动作：
1. 将`call Q`指令后的下一个指令 A 的地址压栈，使得 P 过程栈帧的最低地址保存返回地址
2. 将 PC 设置为过程 Q 代码的起始地址

当过程 Q 执行结束时，过程 Q 会执行`ret`指令，该指令完成如下动作：
1. 从过程 P 的栈帧中弹出返回地址
2. 将 PC 设置为返回地址

这样就完成了过程间的转移控制。

### 数据传送
参数传递是指过程 P 如何将参数传递给过程 Q。为了将数据传递给过程 Q，过程 P 采用如下方式（x86-64 中）：
1. 少于 6 个整型参数时，使用寄存器传参
2. 多余的参数通过栈传递

使用寄存器传参很容易理解：约定寄存器的使用规则就好。
通过栈传递，则需要提前为过程 P（注意，call 之前的栈都算过程 P 的栈帧）的栈帧分配足够的空间以保存额外的参数，然后过程 P 再执行 call 指令，完成转移控制动作。

### 寄存器的管理
虽然任何时刻只有一个过程是活跃的，但是寄存器是被所有过程共享的，这就意味着，我们需要保证当前活跃的过程不去修改其他过程的寄存器现场。但是如果当前过程无法修改其他过程的寄存器，那岂不是会导致被调用过程可以使用的寄存器越来越少？这明显不是一个合理的解决方法。

x86-64 采用统一的寄存器使用惯例来避免这一问题。

* %rbx,$rbp 和%r12~%r15 被约定为被调用者保存寄存器。即：当过程 P 调用过程 Q 时，过程 Q 需要将这些寄存器中的内容保存在自己的栈帧中，当过程 Q 返回时，再将这些值从栈中弹出恢复到它们之前的寄存器中。
* 其他所有除了%rsp 的寄存器，都被约定为调用者保存寄存器。即过程 P 需要保存这些寄存器值在自己的栈帧中，当过程 Q 返回时，再将这些寄存器恢复。

通过这用约定，被调用过程 Q 可以放心使用调用者保存寄存器，因为过程 P 已经保存了这些寄存器的“快照”，在返回过程 P 时，这些寄存器可以安全复原。

### 递归过程
递归就是过程自己调用自己，我们来看个例子。
```c
long rfact(long n){
    long result;
    if( n <= 1){
        result = 1;
    }
    else {
        result = n * rfact(n - 1);
    }
    return result;
}
```
rfact 函数利用递归计算 n 的阶乘。
```bash
_Z5rfactl:
	cmpq	$1, %rdi
	jg	.L8
	movl	$1, %eax
	ret
.L8:
	pushq	%rbx
	movq	%rdi, %rbx
	leaq	-1(%rdi), %rdi
	call	_Z5rfactl
	imulq	%rbx, %rax
	popq	%rbx
	ret
```
`cmp $0x1,%rdi`比较 1 与 %rdi 的大小，很明显，%rdi 保存的是变量 n 的值。

`jg`指令表示如果 n > 1，则跳到.Lb 标记的`push %rbx`指令。

因为本过程需要使用寄存器 %rbx，而 %rbx 是调用者保存寄存器，所以将该寄存器值压栈

`mov %rdi,%rbx`将变量 n 保存到寄存器 %rbx 中，`lea -0x1(%rdi),%rdi`计算 n - 1，保存到 %rdi 中

`call _Z5rfactl` 首先将下一条指令 `imulq %rbx,%rax`的地址压栈，然后递归调用继续从 `cmpq $1, %rdi`开始，此时 %rdi 保存的已经是 n-1，当%rdi==1 时，`movl $1,%eax`将%eax 的内容保存为 1，然后 ret。此时 pc 将会指向 `imulq %rbx,%rax`（call _Z5rfactl）的下一条语句。

该指令计算 %rbx 与 %rax 的乘积保存到 %rax 中，而 %rbx 保存的是 n，%rax 保存的是 rfact(n-1) 的值。这样就完成了阶乘的计算。

此处的`rfact`函数用到的局部变量以及参数都不多，所以过程使用到的栈帧不是很大，就是保存%rbx 以及返回地址。不过如果递归过深也可能会导致栈爆炸。