
<!-- @import "[TOC]" {cmd="toc" depthFrom=1 depthTo=6 orderedList=false} -->

<!-- code_chunk_output -->

- [二进制数的计算机编码](#二进制数的计算机编码)
  - [补数](#补数)
  - [计算机中的补数](#计算机中的补数)
  - [补码系统](#补码系统)

<!-- /code_chunk_output -->


## 二进制数的计算机编码
### 补数
在实际的计算系统中，有限的数字范围才是常态。

以24小时时钟为例，有效数字就是 [0, 23]。当数字范围有限时，就一定会有 A +- B 的结果超出有效范围的情况发生。比如当前时间点是 23 点，`16 + 11 = 27` 超出了表示范围，而在时间系统中，我们习惯的是忽略溢出部分，只关心有效部分，因此在时间系统中，隐含的一个操作是，`(16 + 11) % 24`。

做一个有趣的变换：`(16 + 11) % 24 = (16 + 11 + 24) % 24 = (16 - 13 + 24) % 24`

我们发现，在时钟系统中， + 11 的效果与 -13 的效果一样。换句话说， -13 的效果与 +11 一样。

这里我们称 13 是 11 在 24 进制下的补数。(twenty-four's complement)

补数的严格定义：**补数（complement）是对于给定的进位制，相加后能使自然数 a 的位数增加 1 的最小的数**。

https://zh.wikipedia.org/wiki/%E8%A1%A5%E6%95%B0

### 计算机中的补数
前面提到，在时钟计算系统中，- A 与 + A 的 24‘ complement 效果一样。这个特性对于计算机实现来说非常有吸引力，因为我们实现加法电路非常容易，如果能使用同一套电路实现加减法那么可以降低CPU制造成本。

时钟系统中，上述效果一样的前提是，我们只关心有效部分，不关心溢出部分。而在计算机的二进制加法电路中，天然就有这个特性。

并且对于一个二进制数 101010110，我们可以非常容易计算其补数
101010110 的 2‘s complement 应该是按位取反再 + 1，即 `010101001 + 1 = 010101010`

### 补码系统
补码系统是计算机中使用的用来对二进制数进行编码的规则。

* 正数二进制和0的补码是其本身二进制表示在加上符号位 0
* 负数二进制的补码是其补数的二进制再加上符号位 1

补码系统是为了解决计算机系统中存在的问题提出的，正数二进制以及 0 的计算不存在问题，所以只需要使用其本身的格式就可以。负数二进制采用符号位 + 补数的二进制表示之后，可以将对正数的减法快速变为对对应负数的加法，这才是使用补码系统的目的。

举例：如果没有补码表示，那么对于 -1，其二进制表示应该是 `1000 0001`，最高位为符号位。我们需要一套额外的减法运算电路去进行减法计算，但是将 -1 采用补码表示后 `1111 1111`，当某个数 A 需要 - 1 时，我们只需要将操作数 A 与 `1111 1111` 送入加法电路即可得到结果。

https://zh.wikipedia.org/wiki/%E4%BA%8C%E8%A3%9C%E6%95%B8