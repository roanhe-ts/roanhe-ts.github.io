<!-- TOC -->

- [二分法](#%e4%ba%8c%e5%88%86%e6%b3%95)
  - [使用整数索引时通用的二分法模板](#%e4%bd%bf%e7%94%a8%e6%95%b4%e6%95%b0%e7%b4%a2%e5%bc%95%e6%97%b6%e9%80%9a%e7%94%a8%e7%9a%84%e4%ba%8c%e5%88%86%e6%b3%95%e6%a8%a1%e6%9d%bf)
    - [LeetCode 34. Find First and Last Position of Element in Sorted Array](#leetcode-34-find-first-and-last-position-of-element-in-sorted-array)
    - [LeetCode 35. Search Insert Position](#leetcode-35-search-insert-position)

<!-- /TOC -->

# 二分法

典型情景：有序数组中寻找指定值

```c++
while(start != end){
            auto mid = start + (end - start)/2;
            if(*mid == target)
                return mid - nums.begin();
            else if(*mid < target)
                start = mid;
            else
                end = mid;
        }
```
start 和 end 组成一个迭代器范围，如果循环的进行条件是 start != end，mid = start + (end - start) / 2，则当区间中只剩下一个元素时，会出现无限循环。

使用迭代方式实现二分法时，while 循环中的进行条件最好写成 while(start + 1 != end)，这样只要 start 和 end 相邻，循环就可退出，避免了死循环。这样只需要在循环结束之后增加判断一次 *start 是否等于 target 即可。

```c++
class Solution {
public:
    int search(vector<int>& nums, int target) {
        if(nums.empty()) return -1;
        
        auto start = nums.begin(), end = nums.end();
        while(start + 1 != end){
            auto mid = start + (end - start)/2;
            if(*mid == target)
                return mid - nums.begin();
            else if(*mid < target)
                start = mid;
            else
                end = mid;
        }
        // 
        if(*start == target) return start - nums.begin();
        return -1;
    }
};
```

## 使用整数索引时通用的二分法模板

    start + 1 < end
    start + (end - start) / 2
    A[mid] ==, <, >
    A[start] A[end] ? target

如何取 mid
1. (start + end) / 2
   不好，start 和 end 很大时会出现整数溢出
2. start + (end - start) / 2
   好，考虑到整数溢出

二分法比较适合使用整数索引，不太适合使用迭代器范围

### LeetCode 34. Find First and Last Position of Element in Sorted Array
```c++
class Solution {
public:
    vector<int> searchRange(vector<int>& nums, int target) {
        vector<int> res(2, -1);
        if(nums.empty()) return res;
        
        auto end = nums.size() - 1;
        decltype(end) start = 0;
        
        // 使用二分法通用模板
        // 使用整数索引
        // 先找 lower bound
        while(start + 1 < end){
            auto mid = start + (end - start) / 2;
            // 优先移动 end
            if(nums.at(mid) >= target) 
                end = mid;
            else
                start = mid;
        }
        // 注意顺序
        if(nums.at(end) == target) res[0] = end;
        if(nums.at(start) == target) res[0] = start;
        
        if(res[0] == -1) return res;
        
        // 不需要移动 start
        end = nums.size() - 1;
        // 寻找 upper bound
        while(start + 1 < end){
            auto mid = start + (end - start) - 1;
            // 优先移动 start
            if(nums.at(mid) <= target)
                start = mid;
            else
                end = mid;
        }
        // 注意顺序，与之前相反
        if(nums.at(start) == target) res[1] = start;
        if(nums.at(end) == target) res[1] = end;
        
        return res;
    }
};
```

### LeetCode 35. Search Insert Position

相当于寻找 34 题中 Range 的左侧界限。
```c++
class Solution {
public:
    int searchInsert(vector<int>& nums, int target) {
        if(nums.size() == 0) return 0;
        int start = 0, end = nums.size() - 1;
        
        // 区间左“移”
        while(start + 1 < end){
            auto mid = start + (end - start) / 2;
            if(nums[mid] >= target) 
                end = mid;
            else
                start = mid;
        }


        if(nums[start] >= target)
            return start;
        
        if(nums[end] >= target)
            return end;
        
        return end + 1;
        
    }
};
```