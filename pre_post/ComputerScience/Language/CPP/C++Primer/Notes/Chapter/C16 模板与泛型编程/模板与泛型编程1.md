# 模板与泛型编程1
[TOC]
---
## 定义模板
### 函数模板
```c++
template <typename T>
int compare(const T &v1, const T &v2){
    if (v1 < v2) return -1;
    if (v2 < v1) return 1;
    return 0;
}
```
以关键字`template`开始，后面跟一个模板参数列表（template parameter list)，这是一个逗号分隔的一个或多个模板参数的列表

#### 实例化函数模板
编译器可以根据函数实参来推断出函数模板实例化时需要使用的模板参数实参。

#### 模板类型参数
模板类型参数可以用来指定返回类型或者函数的参数类型。类型参数前必须使用关键字`class`或者`typename`

```c++
template <typename T, typename U> T calc(const T&, const U&);
```

#### 非类型模板参数
一个非类型参数表示一个值而非一个类型。

假设我们要比较两个不同长度的字符串。
```c++
template<unsigned N, unsigned M>
int compare(const char (&p1)[N], const char (&p2)[M])
{
    return strcmp(p1, p2);
}
```
**数组引用形参**
C++语言允许将变量定义成数组的引用。函数的形参也可以是数组的引用。

### 16.1.2 类模板
类模板与函数模板的一个区别在于，当我们实例化一个类模板时，必须显示地提供类模板参数，而函数模板实例化时，模板参数可以由编译器进行推导。

#### 类模板成员函数的实例化
类模板的成员函数只有在程序用到它时才会进行实例化。如果某个成员函数没有被使用，那么它不会被实例化。

这一特性使得即使某种类型不能完全符合模板的操作的全部要求，但是只要我们不去实例化该类型无法满足的成员函数，那么我们依然可以使用该类型实例化某个类模板。

#### 类模板和友元
友元表示某两个类之间的友好关系。当涉及到类模板时，由于每个类模板的实例之间是无关的，那么友元关系的声明就可以有不同的模式。

一种最直观的方式就是要求两个类模板实例之间必须具有相同的类模板实参，这样才可以构成友元关系。
```c++
template <typename T> class A;
template <typename T> void func(T);

template <typename T>
class B{
    friend class A<T>;
    friend void func<T>(T);
};
```
上述代码中，我们首先进行了模板类A和模板函数func的声明。注意，模板声明时必须包含模板参数。
*这种方式称为一对一友元模式。*
```
B<int> b_int;
A<int> a_int;
```
`a_int`是`b_int`的友元类，可以访问`b_int`的私有成员。`a_char`则不是`b_int`的友元类。

#### 类模板的 static 成员

### 16.1.3 模板参数

### 16.1.4 成员模板

### 16.1.5 控制实例化